{"meta":{"title":"Wei.Yz's Blog","subtitle":null,"description":"春天不是编码天，夏日炎炎正好眠。秋有蚊虫冬有雪，收拾包裹好过年。","author":"wei.yz","url":"http://weiYz.github.io","root":"/"},"pages":[],"posts":[{"title":"关于Synchronized的总结","slug":"关于Synchronized的总结","date":"2020-05-13T08:13:00.000Z","updated":"2020-05-13T17:12:47.034Z","comments":true,"path":"2020/05/13/关于Synchronized的总结/","link":"","permalink":"http://weiYz.github.io/2020/05/13/关于Synchronized的总结/","excerpt":"","text":"很多知识学过、用过但没有梳理出来，就很容易忘。synchronized 作为多线程中非常重要的知识点，需要认真理解。synchronized的实现是由 一对儿 monitorEnter 和 monitorExit 指令实现的。 synchronized 可以用来修饰以下 3 个层面： 修饰实例方法； 修饰静态类方法； 修饰代码块。 synchronized 修饰实例方法 这种情况下的锁对象是当前实例对象，因此只有同一个实例对象调用此方法才会产生互斥效果，不同实例对象之间不会有互斥效果。 比如如下代码： 上述代码，在不同的线程中调用的是不同对象的 printLog 方法，因此彼此之间不会有排斥。运行效果如下： 可以看出，两个线程是乱序执行的。 如果将代码进行如下修改，两个线程调用同一个对象的 printLog 方法： 则执行效果如下： 可以看出：只有某一个线程中的代码执行完之后，才会调用另一个线程中的代码。也就是说此时两个线程间是互斥的。 修饰静态类方法 如果 synchronized 修饰的是静态方法，则锁对象是当前类的 Class 对象。因此即使在不同线程中调用不同实例对象，也会有互斥效果。 将 printLog 修改为静态方法，如下： 执行后的打印效果如下： 可以看出，两个线程还是依次执行的。 synchronized 修饰代码块除了直接修饰方法之外，synchronized 还可以作用于代码块，比如DCL的单例模式，如下代码所示： synchronized 作用于代码块时，锁对象就是跟在后面括号中的对象。上图中可以看出任何 Object 对象都可以当作锁对象。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://weiYz.github.io/tags/Java/"}]},{"title":"关于Looper的梳理","slug":"关于Looper的梳理","date":"2018-05-31T17:04:26.000Z","updated":"2020-05-09T17:16:42.538Z","comments":true,"path":"2018/06/01/关于Looper的梳理/","link":"","permalink":"http://weiYz.github.io/2018/06/01/关于Looper的梳理/","excerpt":"","text":"Looper当一个Activity被创建时，ActivityThread的main()方法会被执行。 1234567891011public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);... Looper.prepareMainLooper(); ... Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 主线程Looper的创建是调用Looper的prepareMainLooper()方法来创建Looper对象： 12345678910111213141516public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这里的sThreadLocal对象的类型是ThreadLocal是一个存放在TLS（Thread-local storage)中的对象容器，储存在其中的对象的特点是每个线程中只有一个，并且个线程中储存的该对象不相同。 我们在这里新建了一个Looper对象并放入了TLS中： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; mThread保存了当前运行Looper的进程信息, 而mQueue就是与Looper对应的MessageQueue。 问题：一个线程只能有一个Looper，如何实现的呢？ 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; prepare 重复调用会抛出异常！ 123456789public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 注意： threadlocal正是用的thread对象本身来当key，这样每次在thread里创建一个looper时，系统都会先去全局的threadLocal里的hashmap看看对应的线程id里是否已经存了looper，如果没有，就说明这个线程还没有创建过looper，就正常创建，然后存进hashmap里。如果已经有了，就会报错。如此一来，每个线程就像在自己的环境里保存本地变量一样，互不干扰，这也就是Local的意思。同时，由于message queue是looper里的一个成员，looper是线程唯一的，所以message queue也是线程唯一的.","categories":[],"tags":[]},{"title":"关于MessageQueue的梳理","slug":"关于MessageQueue的梳理","date":"2018-05-10T11:04:42.000Z","updated":"2020-05-09T17:13:35.695Z","comments":true,"path":"2018/05/10/关于MessageQueue的梳理/","link":"","permalink":"http://weiYz.github.io/2018/05/10/关于MessageQueue的梳理/","excerpt":"","text":"MessageQueue1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 构造函数十分简单，除了初始化quitAllowed标记之外，就是对mPtr的初始化了。 那么mPtr是什么呢？可以推测出的是，真正的MessageQueue的创建一定在nativeInit这个Native调用中，也就是说，我们的MessageQueue实际上存在于Native层。 android_os_MessageQueue.cpp: 12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 在Native层创建了一个NativeMessageQueue对象： 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 它的返回值赋给了Java层MessageQueue的mPtr域： 最后一行就将创建的NativeMessageQueue对象的地址转换为一个Java long类型返回，之后调用Native方法的时候就会传入这个参数来找到这个MessageQueue。 初始化过程结束后，回到ActivityThread的main()函数，调用了Looper.loop()函数开始消息循环。 123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper();... final MessageQueue queue = me.mQueue;... for (;;) &#123; Message msg = queue.next(); // might block ，也就是说这里会阻塞 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125;... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125;... msg.recycleUnchecked(); &#125;&#125; 第7行开始了一个无限循环，循环的第一步就是从MessageQueue里面获取一条Message，后面有一个注释告诉我们这个调用可能会阻塞。 接下来检查获取到的msg是否为null，如果为null，那么将会直接退出loop()函数，对于Activity的主线程来说，这个情况只会发生在应用退出的时候。 下面就直接调用了Message的target的dispatchMessage()函数，在使用Handler来发送消息的时候，这个target指的就是Handler本身。 MessageQueue的next()这个函数过程比较长，所以分开来分析。 123456789101112Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123;... // 它的作用是阻塞，当有新的消息或达到超时后返回. nativePollOnce(ptr, nextPollTimeoutMillis); 第一部分是变量的初始化，如果MessageQueue的mPtr为0的话，说明NativeMessageQueue没有正确初始化，返回null结束消息循环。 下面定义了两个变量，第一个pendingIdleHandlerCount初始化为-1，它表示的是将要执行的空闲Handler数量，之后会用到。 第二个nextPollTimeoutMillis就是距下一条消息被处理需要等待的时间。 nativePollOnce()函数，它的作用是阻塞，当有新的消息或达到超时后返回。而这个核心的特性，完全是利用系统提供的epoll机制实现的这点非常重要。 下面的过程，注意看注释： 123456789101112131415161718192021222324252627282930313233343536373839synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); // 获取当前时刻 Message prevMsg = null; Message msg = mMessages; // Message是一个链表的结构，而mMessages相当于&quot;头指针&quot; if (msg != null &amp;&amp; msg.target == null) &#123; // 当message的target为null的时候，被认为是一个特殊的message，我们应当跳过这类message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 当时间还没到message的执行时间时，更新nextPollTimeoutMillis nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // message到时间，需要被处理 mBlocked = false; // 取消阻塞状态标记 // 从链表中取出表头的message if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); // 标记使用状态 return msg; // 返回该message &#125; &#125; else &#123; // msg == null，没有消息 nextPollTimeoutMillis = -1; // 如果该值为-1，nativePullOnce()将会无限执行直到有新的消息通知 &#125; // 处理退出消息循环的请求，返回null退出消息循环 if (mQuitting) &#123; dispose(); return null; &#125; 这就是MessageQueue中获取Message的流程，需要注意的就是Message的链表结构，每次取首元素来进行处理。","categories":[],"tags":[]},{"title":"关于Handler知识的一些总结","slug":"关于Handler知识的一些总结","date":"2018-03-08T16:14:17.000Z","updated":"2020-05-09T17:11:49.785Z","comments":true,"path":"2018/03/09/关于Handler知识的一些总结/","link":"","permalink":"http://weiYz.github.io/2018/03/09/关于Handler知识的一些总结/","excerpt":"","text":"Handler构造Handler的构造方法中除了实现默认参数的相互调用外，有内容的有这么两个： 1234567891011public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 如果传入的了callback，将会保存到mCallback域中，之后的消息处理中会看到。 如果没有传入loop参数，将会使用默认的Looper.myLooper()也就是之前提到过的本线程TLS中储存的Looper对象。mQueue消息队列就是从该Looper中获取的消息队列。 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 如果传入了looper，那么将从它这里获取对应的消息队列对象，之后的消息就会放入这个队列中，这也是Handler实现跨线程通信的基础。 发送消息: 1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; 12345678public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 最终调用的是sendMessageAtTime()方法，发送在特定时刻处理的消息。 然后调用enqueueMessage()方法： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这里的第2行中，将msg的target设置为this也就是这个Handler本身. 当此Handler持有外部类（如Activity）的引用时，Message也就间接的持有此引用，这就是导致Handler内存泄漏的根源 我们回想起消息循环中处理Message的调用： msg.target.dispatchMessage(msg); 现在我们知道，Handler发送的消息被消息队列拿到后，会调用发送它的Handler的dispatchMessage()方法对它进行处理。然后，调用了MessageQueue的enqueueMessage()方法来向消息队列中插入消息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) &#123; // 不允许没有target的Message，这种Message(barrier)只能由系统产生用于唤醒消息队列 if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; // 防止消息被重复处理 if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; // 检查消息队列是否处于退出状态 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 在这三种情况下，这条消息被插入到了队列的头部，因此我们应唤醒消息队列 msg.next = p; mMessages = msg; needWake = mBlocked; // 如果处于阻塞状态，则需要进行唤醒 &#125; else &#123; // 在队列中插入的消息，只有在target为空（barrier）并且设置为异步时，需要进行唤醒操作 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; // 熟悉的链表插入操作 for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break； &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; // 如果有消息不需要进行异步处理，则无需进行唤醒操作 &#125; &#125; // 插入到p结节之前 msg.next = p; prev.next = msg; &#125; // 如果有needWake标记，则进行消息队列的唤醒操作 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 整个方法的流程在注释中进行了分析，这里主要就分为了两种情况，需要进行队列唤醒与无需进行队列唤醒的，如果需要队列唤醒操作（有needWake标记），则会在调用的最后调用nativeWake()方法进行native的唤醒操作。 我们只需要等待设置的时间到达，消息队列就会取出我们发送的消息并进行处理。 消息的处理 消息队列拿到消息后，调用msg.target.dispatchMessage(msg)进行消息的处理，从前文我们了解到，Handler发送的消息的target就是Handler自身，所以调用的就是它的dispatchMessage()方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 这个过程也比较经典，第2行if判断Message是否拥有自己的callback，如果有的话就调用handleCallback()来运行这个Runnable： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 如果没有自带callback，第5行检查Handler是否自带callback，如果有的话就去执行这个callback，但是这里还有一点细节需要注意，如果这个方法返回了false，那么后面Handler自带的handlerMessage()方法同样会被执行，这里其实就是一个执行的优先级顺序的问题，一般情况下我们使用时只会传入callback或是重写Handler的handleMessage()方法，优先级也就是确保一个执行顺序的逻辑。","categories":[],"tags":[]},{"title":"Java价格中的逗号格式收集","slug":"Java价格中的逗号格式收集","date":"2017-02-10T04:22:29.000Z","updated":"2020-05-09T17:27:11.272Z","comments":true,"path":"2017/02/10/Java价格中的逗号格式收集/","link":"","permalink":"http://weiYz.github.io/2017/02/10/Java价格中的逗号格式收集/","excerpt":"","text":"记录一下 以备不时之需 java.text.DecimalFormat类就是专门对数字进行格式化的，通过对该类的应用，可以为要输出的数字加上单位，或者控制数字的精度； 用法：可以在DecimalFormat实例化时传递格式，也可通过对象调用applyPattern方法来实现设置格式。 代码演示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; DecimalFormat df = new DecimalFormat(); double data = 1234.56789; System.out.println(&quot;格式化之前的数字: &quot; + data); //定义要显示的数字的格式 String style = &quot;0.0&quot;; df.applyPattern(style);// 将格式应用于格式化器 System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); //在格式后添加诸如单位等字符 style = &quot;00000.000 kg&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); // 模式中的&quot;#&quot;表示如果该位存在字符，则显示字符，如果不存在，则不显示。 style = &quot;##000.000 kg&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); // 模式中的&quot;-&quot;表示输出为负数，要放在最前面 style = &quot;-000.000&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); // 模式中的&quot;,&quot;在数字中添加逗号，方便读数字 style = &quot;-0,000.0#&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); //模式中的&quot;E&quot;表示输出为指数，&quot;E&quot;之前的字符串是底数的格式， &quot;E&quot;之后的是字符串是指数的格式 style = &quot;0.00E000&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); //模式中的&quot;%&quot;表示乘以100并显示为百分数，要放在最后。 style = &quot;0.00%&quot;; df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df.format(data)); // 模式中的&quot;\\u2030&quot;表示乘以1000并显示为千分数，要放在最后。 style = &quot;0.00\\u2030&quot;; //在构造函数中设置数字格式 DecimalFormat df1 = new DecimalFormat(style); //df.applyPattern(style); System.out.println(&quot;采用style: &quot; + style + &quot;格式化之后: &quot; + df1.format(data));&#125; 程序运行结果为： 注意：最后一个是千分符","categories":[],"tags":[]},{"title":"TV版APP扫码登录方案","slug":"TV版APP扫码登录方案","date":"2016-12-01T04:08:39.000Z","updated":"2017-12-05T07:09:10.415Z","comments":true,"path":"2016/12/01/TV版APP扫码登录方案/","link":"","permalink":"http://weiYz.github.io/2016/12/01/TV版APP扫码登录方案/","excerpt":"","text":"为渠哪得清如，为有源头活水来 1. 扫描登录目前遇到需要扫码有以下场景: 用微信、QQ或者微博进行三方登录； UE要求: 智能电视上输入不方便，在手机页面输入更便利。 实现流程概述: APP端根据Guid注册推送标示（Account/TAG）； 登录时，APP端根据一定规则生成二维码，其中包含能标示此设备的Guid； 手机扫描二维码，根据业务场景需要选择第三方或者自身后台进行鉴权； 鉴权成功后，后台调用推送接口，推送到指定Guid的APP设备； APP端收到此推送，执行登录成功逻辑（推荐使用EventBus,用于异步消息的跨线程处理）。 2. 互踢自身账户体系要求同一账号只能在一个设备登录或指定数目设备同时登录 以优酷土豆为例，假设同一账号同时至多登录 3 台APP设备（可拓展至Web站和Wap站)。 后台需维护一张 userId–devicId–*token–state 的关系表 假设A账户调用登录接口，此时数据库deviceId的在线记录不足 3 条，则插入此记录； 假设A账户调用登录接口，但此时已经存在了 3 条deviceId的在线记录，需根据一定调度策略踢掉某一台设备，同时给此deviceId发送推送消息，并将在线状态state置false。被踢掉的APP若收到此推送则执行互踢逻辑； 假如A账户调用通用接口，后台根据请求参数的deviceId或token判断时候合法，若不在表的在线记录中，在通用返回结果中定义errCode。 被踢掉的设备下一次请求接口时执行互踢逻辑。","categories":[],"tags":[{"name":"Android EventBus","slug":"Android-EventBus","permalink":"http://weiYz.github.io/tags/Android-EventBus/"}]},{"title":"Android开发中的几点小心得","slug":"Android开发中的几点小心得","date":"2016-11-21T09:37:46.000Z","updated":"2017-05-11T03:52:39.000Z","comments":true,"path":"2016/11/21/Android开发中的几点小心得/","link":"","permalink":"http://weiYz.github.io/2016/11/21/Android开发中的几点小心得/","excerpt":"","text":"不积跬步无以至千里，不积小流无以成江河 通用篇 做之前先考虑那些可以公用，资源，layout，类，做一个结构、架构分析以加快开发，提升代码可复用度。 全部Activity可继承自BaseActivity，便于统一风格与处理公共事件，一处修改全局有效，并且注意控制Activity的代码量，保持主要逻辑清晰。 与Activity通讯使用Handler更方便； 如果你的框架回调链变长，考虑监听者模式简化回调。 监听者模式不方便使用时，推荐EventBus框架库，使用时间总线。 全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集。其他类遵守SRP（单一职能），ISP（接口隔离）原则。 Log请打上Tag，调试打印一定要做标记，能定位打印位置，否则尴尬是：不知道是哪里在打印。 异常抛出，在合适的位置处理或者集中处理，不要搞的到处是catch，混乱且性能低，尽量不要在循环体中捕获异常，以提升性能。 构造函数里面极度不推荐启动异步线程，会埋下隐患。 千万不要理所当然的以为一个对象不会为空，充分的做好容错处理。 服务器和客户端尽量统一唯一标识（有可能是ID），否则多少会有歧义和问题。 如果数据没有必要加载，数据请务必延迟初始化，谨记为用户节省内存，总不会有坏处 注释，尽量去写足够的注释，去描述一下思路，达到看了可以明白某一块代码的效果。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://weiYz.github.io/tags/Android/"}]},{"title":"Android开发中View事件分发","slug":"Android开发中View事件分发","date":"2016-02-01T03:30:49.000Z","updated":"2017-12-05T06:53:43.529Z","comments":true,"path":"2016/02/01/Android开发中View事件分发/","link":"","permalink":"http://weiYz.github.io/2016/02/01/Android开发中View事件分发/","excerpt":"","text":"黑发不知勤学早 白首方悔读书迟 Android的View事件分发是个老生常谈的问题，网上很多讲解和教程，但是在《Android开发艺术探索》中看到这一段伪代码，觉得非常之精辟，特记录下来： 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consume=false; if(onInterceptTouchEvent(ev))&#123; consume=onTouchEvent(ev); &#125;else&#123; consume=child.dispatchTouchEvent(ev); &#125; return consume; &#125; 几个比较重要的结论也一并摘录： 当一个点击事件产生后，它的传递过程遵循如下顺序：Activity->Window->View,即事件总是先传递给Activity，Activity在传递给Window，最后Window在传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所用的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法被调用。 正常情况下，一个事件序列只能被一个View拦截且消耗，因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别有两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个View一旦决定拦截，那么这一个事件序列都只能由它处理，并且它的onInterceptTouchEvent不会再被调用。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。 如果View不消耗出ACTION_DOWN以外的其他事件，那么这个点击事件会消失，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。 View没有onInterceptTouchEvent方法，一旦有事件传递给它，那么它的onTouchEvent方法就会被调用。 View的OnTouchEvent方法默认都会消耗事件（返回true）。 View的enable属性不影响onTouchEvent的默认返回值。 onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。 事件的传递过程是由外向内的，即事件总是项传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。(requestDisallowInterceptTouchEvent方法主要设置父元素中的FLAG_DISALLOW_INTERCEPT标记位，一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件）","categories":[],"tags":[{"name":"Android View","slug":"Android-View","permalink":"http://weiYz.github.io/tags/Android-View/"}]},{"title":"Mac上JNI开发遇到的问题总结","slug":"Mac上JNI开发遇到的问题总结","date":"2015-12-05T07:15:51.000Z","updated":"2017-12-05T07:51:33.353Z","comments":true,"path":"2015/12/05/Mac上JNI开发遇到的问题总结/","link":"","permalink":"http://weiYz.github.io/2015/12/05/Mac上JNI开发遇到的问题总结/","excerpt":"","text":"AndroidStudio+Mac 和 Eclipse+Windows的真是区别巨大。1 —&gt; “Java 找不到类名”带包名的，需要在包名最上层的目录执行。例如你的类在xxx/demo(包名)/HelloWorld(类名),然后在xxx/目录下执行javah -jni demo.HelloWorld，在xxx/目录下就会生成.h文件 在MAC Android Studio中 “classpath” 为“从当前目录到包名最上层目录” 的路径 2 —&gt; “java.lang.UnsatisfiedLinkError: Native method not found”；1、c++中的方法Java_xxx_xxx 中的Java首字母一定要大写,注意格式不要写错。 2、如果是 .cpp 文件 则用 extern “C” {“您的方法在这里”}，大括号里是您的本地方法。 3 —&gt;“java.lang.UnsatisfiedLinkError:couldn’t find “libXXX.so”这个问题是因为运行时没有load到指定的so库，检查拼写、路径和gradle配置。 在AndroidStudio中 “android{} ”标签中的“defaultConfig”标签中加入 “NDK”设置12345678910defaultConfig &#123; applicationId \"wei.jni2\" minSdkVersion 15 targetSdkVersion 21 versionCode 1 versionName \"1.0\" ndk &#123; moduleName \"cLib\" // &lt;-- This is the name of my C++ module! &#125;&#125; 4 —&gt; “Type ‘JNICALL’ could not be resolved” Project Properties -&gt; C/C++ General -&gt; Path and Symbols 选择include标签，Add -&gt; $Android_NDK_HOME/platforms/android-14/arch-arm/usr/include 选中All languages. 最后Apply -&gt; OK","categories":[],"tags":[]},{"title":"Android搭建框架细节处理.md","slug":"Android搭建框架细节处理","date":"2015-12-05T06:33:28.000Z","updated":"2017-12-05T07:53:20.487Z","comments":true,"path":"2015/12/05/Android搭建框架细节处理/","link":"","permalink":"http://weiYz.github.io/2015/12/05/Android搭建框架细节处理/","excerpt":"","text":"总结了在新项目开发中遇到的一些需要注意的细节 新建一个团队项目需要注意哪些细节？ 确定三方框架选择，统计分析、分享、推送等； 创建基类及抽象方法，如BaseActivity,BaseFragment,BaseAdapter等; 创建统一风格Dialog&amp;Alert模板、Loading动画、转场动画; 创建统一封装网络请求、图片加载、SP操作、SQLite操作、Toast显示等； 自定APP继承Application, 统一系统常量、统一网络请求地址；","categories":[],"tags":[]},{"title":"JAVA基础数据结构","slug":"JAVA基础数据结构","date":"2015-10-21T11:24:39.000Z","updated":"2017-12-05T06:53:59.313Z","comments":true,"path":"2015/10/21/JAVA基础数据结构/","link":"","permalink":"http://weiYz.github.io/2015/10/21/JAVA基础数据结构/","excerpt":"","text":"骐骥一跃不能十步，驽马十驾功在不舍 首先看一下他们之间的关系Collection ├ List │ ├ LinkedList │ ├ ArrayList │ └ Vector │ └ Stack └ Set ├ HashSet │ └ LinkedHashSet └ TreeSet 对于List:关心的是顺序，它保证维护元素特定的顺序（允许有相同元素），使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素。 对于Set:只关心某元素是否属于Set（不允许有相同元素 ），而不关心它的顺序。 Map├ Hashtable├ HashMap│ ├ LinkedHashMap│ └ WeakHashMap├ TreeMap└ IdentifyHashMap 对于Map:最大的特点是键值映射，且为一一映射，键不能重复，值可以，所以是用键来索引值。Map同样对每个元素保存一份，但这是基于 “ 键 “ 的， Map 也有内置的排序，因而不关心元素添加的顺序。如果添加元素的顺序对你很重要，应该使用 LinkedHashSet 或者 LinkedHashMap。对于效率，Map 由于采用了哈希散列，查找元素时明显比 ArrayList 快。 更为精炼的总结：Collection是对象集合，Collection有两个子接口List 和 Set;List 可以通过下标来取得值，值可以重复;Set 只能通过游标来取值，值不能重复; ArrayList， Vector ， LinkedList 是 List 的实现类;ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的;LinkedList 是线程不安全的，底层是由链表实现的 ; Map 是键值对集合,HashTable 和 HashMap 是 Map的实现类; HashTable 是线程安全的，不能存储 null 值 ;HashMap 不是线程安全的，可以存储 null 值 ;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://weiYz.github.io/tags/JAVA/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://weiYz.github.io/tags/Java/"},{"name":"Android EventBus","slug":"Android-EventBus","permalink":"http://weiYz.github.io/tags/Android-EventBus/"},{"name":"Android","slug":"Android","permalink":"http://weiYz.github.io/tags/Android/"},{"name":"Android View","slug":"Android-View","permalink":"http://weiYz.github.io/tags/Android-View/"},{"name":"JAVA","slug":"JAVA","permalink":"http://weiYz.github.io/tags/JAVA/"}]}